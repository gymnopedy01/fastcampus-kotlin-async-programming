/**
* 멀티 스레드를 사용하면 스케쥴링 알고리즘에 의해 스레드가 전환되면서 작업을 처리하는데 이를 컨텍스트 스위칭 이라 한다
* 하나의 프로세스(process)에는 최소한 하나 이상의 스레드가 존재하고 프로세스 내의 스레드들은 동일한 메모리를 공유한다.
* 스레드는 프로세스를 생성하는 것 보다 가볍다
*
* 하지만 스레드가 무한정 많아지면 메모리 사용량이 높아져서 OOME 가 발생할 수 있고 높은 동시 처리량을 요구하는 시스템에서는 스레드를 생성함녀서 발생하는 대기시간 때문에 응답 지연이 발생한다
* 이런문제를 해결하기 위해선 스레드풀(ThreadPool)을 사용해야 한다. 스레드 풀을 사용하면 애플리케이션 내에서 사용할 총 스레드 수를 제한할 수 있고 기존에 생성된 스레드를 재사용 하므로 빠른 응답이 가능
* 직접 만드는 것보다 검증된 라이브러리를 사용해야 한다 java.util.concurrent 패키지의 ExcutorServce 를 사용하면 쉽고 안전하게 스레드 풀을 사용할 수 있다.
  */

  
# Future
- Future는 비동기 작업에 대한 결과를 얻고 싶은 경우에 사용된다
- 예를 들어 수행 시간이 오래 걸리는 작업이나 작업에 대한 결과를 기다리면서 다른 작업을 병행해서 수행하고 싶은 경우에 유용함
- 스레드는 Runnable을 사용해 비동기 처리를 하지만 퓨처를 사용해 처리 결과를 얻기 위해선 Callable을 사용한다
- 퓨처를 사용하면 비동기 작업을 쉽게 구현할 수 있지만 몇가지 단점을 가지고 있다
- 먼저 get 함수는 비동기 작업의 처리가 완료될 때까지 다음코드로 넘어가지 않고 무한정 대기하거나 지정해둔 타임아웃 시간까지 블로킹 됨
- 또한 퓨처를 사용하면 동시에 실행되는 한개 이상의 비동기 작업에 대한 결과를 하나로 조합하여 처리하거나 수동으로 오나료 처리(completion) 할 수 있는 방법을 지원하지 않음


# 옵저버 패턴
## 1. 옵저버패턴
- 옵저버 패턴이란 gof 가 소개한 디자인 패턴중 하나로 관찰 대상이 되는 객체가 변경되면 대상 객체를 관찰하고 있는 옵저버에게 변경사항을 통지 하는 디자인 패턴을 말한다
- 옵저버 패턴을 사용하면 객체간의 상호 작용을 쉽게 하고 효과적으로 데이터를 전달할 수 있다

## 1.1 옵저버 패턴의 구조
- 옵저버 패턴은 관찰 대상인 서브젝트(Subject) 와 Subject를 관찰하는 옵저버(Observer)로 이뤄져 있다
- 하나의 서브젝트에는 1개 또는 여러개의 옵저버를 등록할 수 있다
- 서브젝트의 상태가 변경되면 자신을 관찰하는 옵저버들에게 변경사항을 통지한다
- 서브젝트로 변경사항을 통지 받은 옵저버는 부가적인 처리를 한다

## 옵저버 패턴의 장점
- 옵저버 패턴을 사용하지 않았다면 고객은 일정 간격으로 커피가 완성됐는지 바리스타에게 확인하는 처리가 있어야함
- 간격이 너무 짧으면 변경된 상태를 빠르게 확인할 수 있지만 매번 불필요한 호출이 발생하므로 성능상 문제가 발생할 수 있음
- 또한 간격이 너무 길면 변경된 상태를 즉시 확인할 수 없으므로 실시간성이 떨어질수 있다
- 옵저버 패턴은 관찰자인 옵저버가 서브젝트의 변화를 신경 쓰지 않고 상태 변경의 주체인 서브젝트가 변경사항을 옵저버에게 알려줌으로써 앞서 언급한 문제를 해결할 수 있다
- 옵저버 패턴은 데이터를 제공하는 측에서 데이터를 소비하는 측에 통지하는 푸시 방식이다

## 옵저버 패턴에서 서브젝트와 옵저버는 고나심사에 따라 역할과 책임이 분리되어있다
- 서브젝트는 옵저버가 어떤 작업을 하는지 옵저버의 상태가 어떤지에 대해 관심을 가질 필요가 없고 오직 변경사항을 통지하는 역할만 수행하고 하나 혹은 다수의 옵저버는 각각 맡은 작업을 스스로 하기 때문에 옵저거 하는일 서브젝트에 영향을 끼치지 않고 옵저버는 단순한 데이터의 소비자로서 존재하게 된다.

# 이터레이터 패턴
## 1. 이터레이터 패턴
- 이터레이터 패턴은 데이터의 집합에서 데이터를 순차적으로 꺼내기 위해 만들어진 디자인 패턴을 말함
- 이터레이터 패턴을 사용하면 컬렉션이 변경되더라도 동일한 인터페이스를 사용해 데이터를 꺼내올 수 있기 때문에 변경사항없이 사용할 수 있다
- 데이터의 집합이 얼만큼의 크기를 가진지 알 수 없는 경우 이터레이터 패턴을 사용하면 순차적으로 데이터를 꺼내올 수 있다
- 애그리게잇(Aggregate)은 요소들의 집합체를 나타낸다
- 이터레이터는 집합체 내부에 구현된 iterator를 이용해 생성한다
- 이터레이터를 사용하는 클라이언트는 생성된 이터레이터의 hasNext 함수를 사용해 데이터가 존재하는지 검사하고 netxt 함수를 사용해 데이터를 꺼낸다.

# 리액티브프로그래밍
- 리액티브 프로그래밍은 데이터 또는 이벤트의 변경이 발생하면 이에 반응해 처리 하는 프로그래밍 기법을 말한다
- 리액티브 프로그래밍은 비동기 프로그래밍을 처리하는 새로운 접근방식
- 2010년 에릭 마이어에 의해 마이크로소프트 .net 에코 시스템으로 정의됨
- 리액티브 프로그래밍은 데이터의 통지, 완료, 에러에 대한 처리를 옵저버 패턴에 영감을 받아 설계되었고 데이터의 손쉬운 비동기 처리를 위해 함수형 언어의 접근 방식을 사용

# 리액티브 프로그래밍을 적용한 사례
- 리액티브 프로그래밍을 사용하면 콜백 헬 문제를 함수형 프로그래밍 관점으로 해결할 수 있다
- 콜백 헬 없이 비동기 코드를 쉽게 작성할 수 있기 때문에 서버나 UI 애플리케이션 개발시 리액티브 프로그래밍이 유용하게 사용되고 있다.